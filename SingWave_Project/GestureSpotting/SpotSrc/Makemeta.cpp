// #include "pch.h"
#include <SDKDDKVer.h>       // by hklee

#include "stdafx.h"
#include "Spot.h"
#include "utils.h"

#define HIMETRICINCH	2540
#define META_EXPAND		10	// by THPARK 95.10.17 modified from 0
#define METAFILE_KEY	0x9AC6CDD7L

typedef struct {
	DWORD	key;		/* 0x9AC6CDD7 */
	WORD	hmf;
	short	left;		/* Bounding Box */
	short	top;		/* Bounding Box */
	short	right;		/* Bounding Box */
	short	bottom;		/* Bounding Box */
	WORD	inch;		/* Unit(Dot) Per Inch: DPI */
	DWORD	reserved;
	WORD	checksum;	/* XOR Checksum for first 10 WORD's */
	WORD	align;		/* added for long alignment proble in Win32 */
} METAFILEHEADER, FAR *LPMETAFILEHEADER;

#define MFH_SIZE	(sizeof(METAFILEHEADER) - sizeof(WORD))

CDC* GetMyDC( CView* pView )
{
	CDC* pDC = pView->GetDC();

	SHORT nRes = pDC->GetDeviceCaps( LOGPIXELSX );
	pDC->SetMapMode(MM_ISOTROPIC);
	pDC->SetWindowOrg(0, 0);
	pDC->SetViewportOrg(0, 0);
	pDC->SetWindowExt(LOG_RESOLUTION, LOG_RESOLUTION);
	pDC->SetViewportExt(nRes, nRes);

	return (pDC);
}

REAL GetLogOnePixel( CView* pView )
{
	CDC* pDC = pView->GetDC();
	REAL rPixel = (REAL)LOG_RESOLUTION / pDC->GetDeviceCaps(LOGPIXELSX);
	pView->ReleaseDC( pDC );

	return rPixel;
}

CMetaFileDC* InitMetaFileDC( CView* pView, CRect* pRect )
{
	CRect			rc;
	CMetaFileDC*	pMetaDC;
	int				nXdpi, nYdpi;

	pMetaDC = new CMetaFileDC;
	if (!pMetaDC)
		return NULL;

	CDC* pDC = pView->GetDC();
    nXdpi = GetDeviceCaps( pDC->m_hDC, LOGPIXELSX );
    nYdpi = GetDeviceCaps( pDC->m_hDC, LOGPIXELSY );
	pView->ReleaseDC( pDC );

	rc.left   = (int) MulDiv(pRect->left, HIMETRICINCH, nXdpi);
	rc.top    = (int) MulDiv(pRect->top, HIMETRICINCH, nYdpi);
	rc.right  = (int) MulDiv(pRect->right, HIMETRICINCH, nXdpi);
	rc.bottom = (int) MulDiv(pRect->bottom, HIMETRICINCH, nYdpi);
	pMetaDC->CreateEnhanced(NULL, NULL, &rc, 
				"HMM matching process\nGenerated by hklee");
	
	return pMetaDC;
}

WORD APMChecksum( METAFILEHEADER* papm )
{
	WORD* pw = (WORD*)papm;
	WORD  wSum = 0;

	// The checksum in a Placeable Metafile header is calculated
	// by XOR-ing the first 10 words of the header.

	for (int i = 0; i < 10; i++)
		wSum ^= *pw++;

	return wSum;
}

BOOL ExportMetafile( CDC* pDC, HENHMETAFILE hMetaBit, 
					char* pszFile, CRect* prc )
{
	ENHMETAHEADER	emh;
	UINT			uiSize;
	int				nXdpi, nYdpi;

    if ( !GetEnhMetaFileHeader(hMetaBit, sizeof(emh), &emh) )
		return FALSE;
	
	uiSize = GetWinMetaFileBits( hMetaBit, 0, NULL, 
								MM_ANISOTROPIC, pDC->m_hDC );
	if (uiSize == 0)
		return FALSE;

    nXdpi = GetDeviceCaps( pDC->m_hDC, LOGPIXELSX );
    nYdpi = GetDeviceCaps( pDC->m_hDC, LOGPIXELSY );

	FILE* fp;
	METAFILEHEADER	mfHeader;

	/* Set meta-header */
	mfHeader.key	= METAFILE_KEY;
	mfHeader.hmf	= NULL;
	mfHeader.inch	= LOG_RESOLUTION;	/* Unit(Dot) Per Inch: DPI */
    mfHeader.left   = (short) MulDiv(emh.rclBounds.left,   mfHeader.inch, nXdpi);
    mfHeader.top    = (short) MulDiv(emh.rclBounds.top,    mfHeader.inch, nYdpi);
    mfHeader.right  = (short) MulDiv(emh.rclBounds.right,  mfHeader.inch, nXdpi);
    mfHeader.bottom = (short) MulDiv(emh.rclBounds.bottom, mfHeader.inch, nYdpi);
	mfHeader.reserved = 0L;
	mfHeader.checksum = APMChecksum( &mfHeader );

	if ( !(fp = fopen(pszFile, "wb")) ) {
		Warning("(CGestureDoc::ExportMetafile) can not open file %s",
				pszFile );
		return FALSE;
	}

	BYTE*	pBits = new BYTE[uiSize];

	if ( !GetWinMetaFileBits(hMetaBit, uiSize, pBits, 
					MM_ANISOTROPIC, pDC->m_hDC) ) {
		delete[] pBits;
		fclose(fp);
		return FALSE;
	}

	if ( !fwrite(&mfHeader, 1, MFH_SIZE, fp) ||
		 !fwrite(pBits, 1, uiSize, fp) ) {
		delete[] pBits;
		fclose( fp );
		return FALSE;
	}
	delete[] pBits;
	fclose( fp );

	return TRUE;
}
